[{"id":"email","user_id":"d5f14370-de3d-47d6-b47d-3493ec9e2df2","name":"Email","content":"\"\"\"title: Email Access\nauthor: RobbyV2\ndate: 2025-03-02\nversion: 2.0\nlicense: MIT\ndescription: A tool for interacting with emails using IMAP and SMTP with markdown support.\nrequirements: markdown\nrequired_open_webui_version: 0.6.0\"\"\"\n\nimport os\nimport smtplib\nimport imaplib\nfrom typing import List, Dict, Any, Callable, Optional\nfrom pydantic import BaseModel, Field\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nimport email\nfrom datetime import datetime\nimport markdown\n\n\nclass EventEmitter:\n    def __init__(self, event_emitter: Callable[[dict], Any] = None):\n        self.event_emitter = event_emitter\n\n    async def progress_update(self, description):\n        await self.emit(description)\n\n    async def error_update(self, description):\n        await self.emit(description, \"error\", True)\n\n    async def success_update(self, description):\n        await self.emit(description, \"success\", True)\n\n    async def emit(self, description=\"Unknown State\", status=\"in_progress\", done=False):\n        if self.event_emitter:\n            await self.event_emitter(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\n                        \"status\": status,\n                        \"description\": description,\n                        \"done\": done,\n                    },\n                }\n            )\n\n\nclass Tools:\n    class Valves(BaseModel):\n        FROM_EMAIL: str = Field(\n            default=os.getenv(\"EMAIL_ADDRESS\", \"sin@musicheardworldwide.com\"),\n            description=\"Sender email address\",\n        )\n        PASSWORD: str = Field(\n            default=os.getenv(\"EMAIL_PASSWORD\", \"WORLDOFSIN1!\"),\n            description=\"Sender email password\",\n        )\n        SMTP_SERVER: str = Field(\n            default=os.getenv(\"SMTP_SERVER\", \"musicheardworldwide.com\"),\n            description=\"SMTP server hostname\",\n        )\n        SMTP_PORT: int = Field(\n            default=int(os.getenv(\"SMTP_PORT\", 465)), description=\"SMTP server port\"\n        )\n        IMAP_SERVER: str = Field(\n            default=os.getenv(\"IMAP_SERVER\", \"musicheardworldwide.com\"),\n            description=\"IMAP server hostname\",\n        )\n        IMAP_PORT: int = Field(\n            default=int(os.getenv(\"IMAP_PORT\", 993)), description=\"IMAP server port\"\n        )\n        CITATION: bool = Field(\n            default=True, description=\"Attach citation metadata to messages\"\n        )\n\n    def __init__(self):\n        self.valves = self.Valves()\n        self.citation = self.valves.CITATION\n\n    def markdown_to_html(self, markdown_text: str) -> str:\n        \"\"\"Convert markdown to HTML format.\"\"\"\n        try:\n            html = markdown.markdown(markdown_text)\n            return f\"<html><body>{html}</body></html>\"\n        except Exception:\n            return f\"<html><body><pre>{markdown_text}</pre></body></html>\"\n\n    async def send_email(\n        self,\n        subject: str,\n        body: str,\n        recipients: List[str],\n        __event_emitter__: Callable[[dict], Any] = None,\n    ) -> str:\n        emitter = EventEmitter(__event_emitter__)\n        msg = MIMEMultipart(\"alternative\")\n        msg[\"Subject\"] = subject\n        msg[\"From\"] = self.valves.FROM_EMAIL\n        msg[\"To\"] = \", \".join(recipients)\n\n        msg.attach(MIMEText(body, \"plain\"))\n        msg.attach(MIMEText(self.markdown_to_html(body), \"html\"))\n\n        try:\n            await emitter.progress_update(\"Connecting to SMTP server...\")\n            with smtplib.SMTP_SSL(\n                self.valves.SMTP_SERVER, self.valves.SMTP_PORT\n            ) as server:\n                server.login(self.valves.FROM_EMAIL, self.valves.PASSWORD)\n                server.sendmail(self.valves.FROM_EMAIL, recipients, msg.as_string())\n\n            await emitter.success_update(\"Email sent successfully.\")\n            return f\"âœ“ Email sent to {', '.join(recipients)} regarding: {subject}\"\n        except Exception as e:\n            await emitter.error_update(str(e))\n            return f\"Error sending email: {str(e)}\"\n\n    async def list_email_folders(\n        self, __event_emitter__: Callable[[dict], Any] = None\n    ) -> List[str]:\n        emitter = EventEmitter(__event_emitter__)\n        try:\n            await emitter.progress_update(\"Connecting to IMAP server...\")\n            mail = imaplib.IMAP4_SSL(self.valves.IMAP_SERVER, self.valves.IMAP_PORT)\n            mail.login(self.valves.FROM_EMAIL, self.valves.PASSWORD)\n            status, folders = mail.list()\n            mail.logout()\n\n            if status != \"OK\":\n                raise Exception(\"Failed to retrieve folders.\")\n            return [f.decode().split(' \"/\" ')[-1] for f in folders]\n        except Exception as e:\n            await emitter.error_update(str(e))\n            return [f\"Error: {str(e)}\"]\n\n    async def get_recent_emails(\n        self,\n        count: int = 5,\n        folder: str = \"INBOX\",\n        __event_emitter__: Callable[[dict], Any] = None,\n    ) -> List[Dict[str, Any]]:\n        emitter = EventEmitter(__event_emitter__)\n        try:\n            await emitter.progress_update(\"Connecting to IMAP server...\")\n            mail = imaplib.IMAP4_SSL(self.valves.IMAP_SERVER, self.valves.IMAP_PORT)\n            mail.login(self.valves.FROM_EMAIL, self.valves.PASSWORD)\n            mail.select(folder)\n            result, data = mail.search(None, \"ALL\")\n            email_ids = data[0].split()[-count:]\n\n            emails = []\n            for num in email_ids:\n                result, msg_data = mail.fetch(num, \"(RFC822)\")\n                raw_email = msg_data[0][1]\n                msg = email.message_from_bytes(raw_email)\n\n                content = \"\"\n                if msg.is_multipart():\n                    for part in msg.walk():\n                        if part.get_content_type() == \"text/plain\":\n                            content = part.get_payload(decode=True).decode()\n                            break\n                else:\n                    content = msg.get_payload(decode=True).decode()\n\n                emails.append(\n                    {\n                        \"subject\": msg[\"subject\"],\n                        \"from\": msg[\"from\"],\n                        \"to\": msg[\"to\"],\n                        \"date\": msg[\"date\"],\n                        \"content\": content,\n                    }\n                )\n\n            mail.logout()\n            await emitter.success_update(f\"Retrieved {len(emails)} emails.\")\n            return emails\n        except Exception as e:\n            await emitter.error_update(str(e))\n            return [{\"error\": str(e)}]\n","specs":[{"name":"get_recent_emails","description":"","parameters":{"properties":{"count":{"default":5,"type":"integer"},"folder":{"default":"INBOX","type":"string"}},"type":"object"}},{"name":"list_email_folders","description":"","parameters":{"properties":{},"type":"object"}},{"name":"markdown_to_html","description":"Convert markdown to HTML format.","parameters":{"properties":{"markdown_text":{"type":"string"}},"required":["markdown_text"],"type":"object"}},{"name":"send_email","description":"","parameters":{"properties":{"subject":{"type":"string"},"body":{"type":"string"},"recipients":{"items":{"type":"string"},"type":"array"}},"required":["subject","body","recipients"],"type":"object"}}],"meta":{"description":"Allow the LLM to send and receive emails at \"sin@musicheardworldwide.com\"","manifest":{}},"access_control":{},"updated_at":1749071280,"created_at":1748983509}]