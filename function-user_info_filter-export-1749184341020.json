[{"id":"user_info_filter","user_id":"d5f14370-de3d-47d6-b47d-3493ec9e2df2","name":"User Info Filter","type":"filter","content":"import platform\nimport psutil\nfrom datetime import datetime\nfrom pydantic import BaseModel, Field\nfrom typing import Callable, Awaitable, Optional, Dict\nimport socket\nimport logging\nimport traceback\n\n# Configure logging\nlogger = logging.getLogger(\"ip_filter\")\nhandler = logging.StreamHandler()\nhandler.setFormatter(logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\"))\nlogger.addHandler(handler)\nlogger.setLevel(logging.INFO)\n\n\ndef handle_error(exception: Exception, function_name: str, inputs: dict) -> dict:\n    error_message = str(exception)\n    stack_trace = traceback.format_exc()\n    logger.error(f\"Error in {function_name}: {error_message}\")\n    logger.debug(f\"Stack Trace:\\n{stack_trace}\")\n    return {\n        \"error\": True,\n        \"function\": function_name,\n        \"message\": error_message,\n        \"stack_trace\": stack_trace,\n        \"inputs\": inputs,\n    }\n\n\nclass Filter:\n    class Valves(BaseModel):\n        \"\"\"System configuration options\"\"\"\n\n        ALLOW_ID_RETRIEVAL: bool = Field(default=True)\n        ALLOW_NAME_RETRIEVAL: bool = Field(default=True)\n        ALLOW_EMAIL_RETRIEVAL: bool = Field(default=True)\n        ALLOW_ROLE_RETRIEVAL: bool = Field(default=True)\n        INJECT_DATE_TIME: bool = Field(default=True)\n        INJECT_MACHINE_INFO: bool = Field(default=True)\n        INJECT_SERVER_IPS: bool = Field(default=True)  # New valve for server IPs\n\n    class UserValves(BaseModel):\n        \"\"\"User-specific exclusions\"\"\"\n\n        EXCLUDE_USER_ID: bool = Field(default=False)\n        EXCLUDE_USER_NAME: bool = Field(default=False)\n        EXCLUDE_USER_EMAIL: bool = Field(default=False)\n        EXCLUDE_USER_ROLE: bool = Field(default=False)\n\n    def __init__(self):\n        self.valves = self.Valves()\n        self.server_ips = self._get_server_ips()\n\n    def _get_server_ips(self) -> dict:\n        \"\"\"Get server IP addresses on initialization\"\"\"\n        try:\n            private_ip = socket.gethostbyname(socket.gethostname())\n            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:\n                s.connect((\"8.8.8.8\", 80))\n                public_ip = s.getsockname()[0]\n            return {\"private\": private_ip, \"public\": public_ip}\n        except Exception as e:\n            logger.error(f\"IP retrieval error: {str(e)}\")\n            return {\"private\": None, \"public\": None}\n\n    def _get_machine_info(self) -> dict:\n        \"\"\"Fetch machine hardware and system info\"\"\"\n        try:\n            machine_info = {\n                \"hostname\": platform.node(),\n                \"platform\": platform.platform(),\n                \"architecture\": platform.architecture()[0],\n                \"processor\": platform.processor(),\n                \"cpu_cores\": {\n                    \"physical\": psutil.cpu_count(logical=False),\n                    \"logical\": psutil.cpu_count(logical=True),\n                },\n                \"ram\": f\"{psutil.virtual_memory().total / (1024 ** 3):.2f} GB\",\n                \"disk\": f\"{psutil.disk_usage('/').total / (1024 ** 3):.2f} GB\",\n            }\n            return machine_info\n        except Exception as e:\n            logger.error(f\"Machine info retrieval error: {str(e)}\")\n            return {\"error\": str(e)}\n\n    async def inlet(\n        self,\n        body: dict,\n        user_ip: Optional[str] = None,\n        user_agent: Optional[str] = None,\n        user: Optional[dict] = None,\n        __event_emitter__: Optional[Callable[[dict], Awaitable[None]]] = None,\n    ) -> dict:\n        \"\"\"Main processing method\"\"\"\n        try:\n            # Validate required body structure\n            if not isinstance(body, dict):\n                return {\"error\": \"Body must be a dictionary\"}\n            if \"messages\" not in body:\n                return {\"error\": \"Missing 'messages' in body\"}\n\n            result = []\n\n            # Handle user info\n            user_valves_data = user.get(\"valves\", {}) if user else {}\n            user_valves = (\n                self.UserValves(**user_valves_data)\n                if isinstance(user_valves_data, dict)\n                else self.UserValves()\n            )\n\n            if user:\n                user_info = [\n                    (\n                        self.valves.ALLOW_ID_RETRIEVAL,\n                        user_valves.EXCLUDE_USER_ID,\n                        \"id\",\n                        \"ID: {val}\",\n                    ),\n                    (\n                        self.valves.ALLOW_NAME_RETRIEVAL,\n                        user_valves.EXCLUDE_USER_NAME,\n                        \"name\",\n                        \"User: {val}\",\n                    ),\n                    (\n                        self.valves.ALLOW_EMAIL_RETRIEVAL,\n                        user_valves.EXCLUDE_USER_EMAIL,\n                        \"email\",\n                        \"Email: {val}\",\n                    ),\n                    (\n                        self.valves.ALLOW_ROLE_RETRIEVAL,\n                        user_valves.EXCLUDE_USER_ROLE,\n                        \"role\",\n                        \"Role: {val}\",\n                    ),\n                ]\n                for allow, exclude, key, fmt in user_info:\n                    if allow and not exclude and key in user:\n                        result.append(fmt.format(val=user[key]))\n\n            # Add user IP information\n            if user_ip:\n                result.append(f\"User IP: {user_ip}\")\n\n            # Add server timestamp if enabled\n            if self.valves.INJECT_DATE_TIME:\n                result.append(f\"Server Time: {datetime.now().isoformat()}\")\n\n            # Add server IPs if enabled\n            if self.valves.INJECT_SERVER_IPS and self.server_ips:\n                if self.server_ips[\"private\"]:\n                    result.append(f\"Server Private IP: {self.server_ips['private']}\")\n                if self.server_ips[\"public\"]:\n                    result.append(f\"Server Public IP: {self.server_ips['public']}\")\n\n            # Add machine info if enabled\n            if self.valves.INJECT_MACHINE_INFO:\n                machine_info = self._get_machine_info()\n                if \"error\" not in machine_info:\n                    result.extend(\n                        [\n                            f\"Hostname: {machine_info['hostname']}\",\n                            f\"Platform: {machine_info['platform']}\",\n                            f\"CPU: {machine_info['processor']} (Cores: {machine_info['cpu_cores']['physical']}P/{machine_info['cpu_cores']['logical']}L)\",\n                            f\"RAM: {machine_info['ram']}\",\n                            f\"Disk: {machine_info['disk']}\",\n                        ]\n                    )\n\n            # Update system message\n            system_message = {\n                \"role\": \"system\",\n                \"content\": \" | \".join(result) if result else \"No context available\",\n            }\n\n            # Ensure messages exists and is a list\n            if not isinstance(body.get(\"messages\"), list):\n                body[\"messages\"] = []\n            body[\"messages\"].insert(0, system_message)\n\n            return body\n        except Exception as e:\n            return handle_error(e, \"inlet\", {\"body\": body, \"user_ip\": user_ip})\n","meta":{"description":"add user info to context without having to use a tool","manifest":{}},"is_active":true,"is_global":true,"updated_at":1749064395,"created_at":1748983541}]